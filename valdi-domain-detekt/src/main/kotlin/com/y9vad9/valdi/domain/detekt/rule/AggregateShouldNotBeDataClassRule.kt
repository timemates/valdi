package com.y9vad9.valdi.domain.detekt.rule

import io.gitlab.arturbosch.detekt.api.CodeSmell
import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.api.Debt
import io.gitlab.arturbosch.detekt.api.Entity
import io.gitlab.arturbosch.detekt.api.Issue
import io.gitlab.arturbosch.detekt.api.Rule
import io.gitlab.arturbosch.detekt.api.Severity
import org.jetbrains.kotlin.psi.KtClass
import org.jetbrains.kotlin.psi.KtModifierListOwner

/**
 * A Detekt rule that enforces that classes annotated with @AggregateRoot
 * should not be Kotlin data classes.
 *
 * Aggregate roots model domain consistency boundaries and often manage
 * mutable state and invariants, which don't fit well with the implicit
 * behavior generated by data classes.
 */
public class AggregateShouldNotBeDataClassRule(config: Config) : Rule(config) {
    override val issue: Issue = Issue(
        id = javaClass.name,
        severity = Severity.CodeSmell,
        description = """
            Classes annotated with @AggregateRoot should not be Kotlin data classes.
            
            Aggregate roots encapsulate complex business logic and invariants,
            and allowing data classes can inadvertently expose mutation and copying
            which violates aggregate encapsulation.
        """.trimIndent(),
        debt = Debt.FIVE_MINS,
    )

    override fun visitClass(klass: KtClass) {
        if (!klass.hasAnnotation("AggregateRoot")) return

        if (klass.isData()) {
            report(
                CodeSmell(
                    issue = issue,
                    entity = Entity.atName(klass),
                    message = "@AggregateRoot class '${klass.name}' should not be a Kotlin data class.",
                )
            )
        }

        super.visitClass(klass)
    }

    private fun KtModifierListOwner.hasAnnotation(name: String): Boolean {
        return annotationEntries.any { it.shortName?.asString() == name }
    }
}
